<!DOCTYPE html>
<html>
<head>
    <title>270Â°ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ - Saito Programming Hub</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        #canvas-container { position: relative; margin-top: 20px; }
        canvas { background: white; border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.1); cursor: pointer; }
        .controls { margin-bottom: 20px; }
        #angle-display { font-size: 2rem; font-weight: bold; color: #333; margin: 10px; }
        button { padding: 10px 20px; font-size: 1rem; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 5px; }
    </style>
</head>
<body>

    <h1>270Â°ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</h1>
    
    <div class="controls">
        <button id="connect">ãƒã‚¤ã‚¯ãƒ­ãƒ“ãƒƒãƒˆã«æ¥ç¶šã™ã‚‹(baudRateï¼š115200bps)</button>
    </div>

    <div id="angle-display">135Â°</div>

    <div id="canvas-container">
        <canvas id="gauge" width="300" height="300"></canvas>
    </div>

	<div>
    	<a href="/">æˆ»ã‚‹</a>
    </div>

    <script>
        let port;
        let writer;
        const canvas = document.getElementById('gauge');
        const ctx = canvas.getContext('2d');
        const angleDisplay = document.getElementById('angle-display');
        const connectBtn = document.getElementById('connect');
        
        let isDragging = false;
        let currentAngle = 135; // 0 to 270

        // æç”»è¨­å®š
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 120;
        const startAngleOffset = 135 * (Math.PI / 180); // é–‹å§‹ä½ç½® (å·¦ä¸‹)

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // èƒŒæ™¯ã®å††å¼§ (270åº¦åˆ†)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngleOffset, startAngleOffset + (270 * Math.PI / 180));
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.stroke();

            // é¸æŠä¸­ã®å††å¼§
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngleOffset, startAngleOffset + (currentAngle * Math.PI / 180));
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.stroke();

            // ã¤ã¾ã¿ (ãƒãƒ³ãƒ‰ãƒ«)
            const handleAngle = startAngleOffset + (currentAngle * Math.PI / 180);
            const handleX = centerX + Math.cos(handleAngle) * radius;
            const handleY = centerY + Math.sin(handleAngle) * radius;

            ctx.beginPath();
            ctx.arc(handleX, handleY, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.shadowBlur = 5;
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // åº§æ¨™ã‹ã‚‰è§’åº¦ã‚’è¨ˆç®—
        function updateAngle(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left - centerX;
            const y = (e.clientY || e.touches[0].clientY) - rect.top - centerY;
            
            let angleRad = Math.atan2(y, x) - startAngleOffset;
            while (angleRad < 0) angleRad += Math.PI * 2;
            
            let angleDeg = angleRad * (180 / Math.PI);
            
            // 270åº¦åˆ¶é™
            if (angleDeg > 270 && angleDeg < 315) angleDeg = 270;
            if (angleDeg >= 315) angleDeg = 0;
            
            currentAngle = Math.round(angleDeg);
            angleDisplay.innerText = `${currentAngle}Â°`;
            draw();
            sendAngle(currentAngle);
        }

        // ã‚·ãƒªã‚¢ãƒ«é€šä¿¡
        async function sendAngle(angle) {
            if (writer) {
                const data = new TextEncoder().encode(angle + "\r\n");
                await writer.write(data);
            }
        }

        connectBtn.addEventListener('click', async () => {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 152000 });
                writer = port.writable.getWriter();
				connectBtn.textContent = "ğŸ”Œ æ¥ç¶šä¸­...";
                connectBtn.disabled = true;
            } catch (err) {
                console.error(err);
            }
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        canvas.addEventListener('mousedown', (e) => { isDragging = true; updateAngle(e); });
        window.addEventListener('mousemove', (e) => { if (isDragging) updateAngle(e); });
        window.addEventListener('mouseup', () => { isDragging = false; });
        // ã‚¿ãƒƒãƒå¯¾å¿œ
        canvas.addEventListener('touchstart', (e) => { isDragging = true; updateAngle(e); e.preventDefault(); }, {passive: false});
        window.addEventListener('touchmove', (e) => { if (isDragging) updateAngle(e); }, {passive: false});
        window.addEventListener('touchend', () => { isDragging = false; });

        draw();
    </script>
</body>
</html>
