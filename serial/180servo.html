<!DOCTYPE html>
<html>
<head>
    <title>180Â°ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ - Saito Programming Hub</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        #canvas-container { position: relative; margin-top: 20px; }
        canvas { background: white; border-radius: 150px 150px 20px 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); cursor: pointer; }
        .controls { margin-bottom: 20px; }
        #angle-display { font-size: 2rem; font-weight: bold; color: #333; margin: 10px; }
        button { padding: 10px 20px; font-size: 1rem; cursor: pointer; background: #28a745; color: white; border: none; border-radius: 5px; }
    </style>
</head>
<body>

    <h1>180Â°ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</h1>
    
    <div class="controls">
        <button id="connect">ãƒã‚¤ã‚¯ãƒ­ãƒ“ãƒƒãƒˆã«æ¥ç¶šã™ã‚‹(baudRateï¼š115200bps)</button>
    </div>

    <div id="angle-display">0Â°</div>

    <div id="canvas-container">
        <canvas id="gauge" width="300" height="200"></canvas>
    </div>

	<div>
    	<a href="/">æˆ»ã‚‹</a>
    </div>

    <script>
        let port;
        let writer;
        const canvas = document.getElementById('gauge');
        const ctx = canvas.getContext('2d');
        const angleDisplay = document.getElementById('angle-display');
        const connectBtn = document.getElementById('connect');
        
        let isDragging = false;
        let currentAngle = 90; // 0 to 180

        // æç”»è¨­å®š
        const centerX = canvas.width / 2;
        const centerY = canvas.height - 40; // ä¸‹å´ã«é‡å¿ƒã‚’ç½®ã
        const radius = 120;
        const startAngleOffset = Math.PI; // 180åº¦ (çœŸå·¦) ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // èƒŒæ™¯ã®å††å¼§ (180åº¦åˆ†)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngleOffset, startAngleOffset + Math.PI);
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 25;
            ctx.lineCap = 'round';
            ctx.stroke();

            // é¸æŠä¸­ã®å††å¼§
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngleOffset, startAngleOffset + (currentAngle * Math.PI / 180));
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 25;
            ctx.lineCap = 'round';
            ctx.stroke();

            // ã¤ã¾ã¿ (ãƒãƒ³ãƒ‰ãƒ«)
            const handleAngle = startAngleOffset + (currentAngle * Math.PI / 180);
            const handleX = centerX + Math.cos(handleAngle) * radius;
            const handleY = centerY + Math.sin(handleAngle) * radius;

            ctx.beginPath();
            ctx.arc(handleX, handleY, 15, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.shadowBlur = 5;
            ctx.shadowColor = "rgba(0,0,0,0.3)";
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // åº§æ¨™ã‹ã‚‰è§’åº¦ã‚’è¨ˆç®—
        function updateAngle(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left - centerX;
            const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top - centerY;
            
            // atan2ã¯å³ãŒ0åº¦ãªã®ã§ã€å·¦(PI)ã‚’åŸºæº–ã«ã™ã‚‹ã‚ˆã†èª¿æ•´
            let angleRad = Math.atan2(y, x) - startAngleOffset;
            
            // è§’åº¦ã®æ­£è¦åŒ–
            while (angleRad < 0) angleRad += Math.PI * 2;
            while (angleRad > Math.PI * 2) angleRad -= Math.PI * 2;
            
            let angleDeg = angleRad * (180 / Math.PI);
            
            // 180åº¦åˆ¶é™ (ä¸‹åŠåˆ†ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ãŸæ™‚ã®æŒ™å‹•ã‚’åˆ¶é™)
            if (angleDeg > 180) {
                angleDeg = (angleDeg > 270) ? 0 : 180;
            }
            
            currentAngle = Math.round(angleDeg);
            angleDisplay.innerText = `${currentAngle}Â°`;
            draw();
            sendAngle(currentAngle);
        }

        // ã‚·ãƒªã‚¢ãƒ«é€ä¿¡
        async function sendAngle(angle) {
            if (writer) {
                try {
                    const data = new TextEncoder().encode(angle + "\n");
                    await writer.write(data);
                } catch (e) {
                    console.error("é€ä¿¡ã‚¨ãƒ©ãƒ¼:", e);
                }
            }
        }

        connectBtn.addEventListener('click', async () => {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 152000 });
                writer = port.writable.getWriter();
				connectBtn.textContent = "ğŸ”Œ æ¥ç¶šä¸­...";
                connectBtn.disabled = true;
            } catch (err) {
                console.error(err);
            }
        });

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        canvas.addEventListener('mousedown', (e) => { isDragging = true; updateAngle(e); });
        window.addEventListener('mousemove', (e) => { if (isDragging) updateAngle(e); });
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        canvas.addEventListener('touchstart', (e) => { isDragging = true; updateAngle(e); e.preventDefault(); }, {passive: false});
        window.addEventListener('touchmove', (e) => { if (isDragging) updateAngle(e); }, {passive: false});
        window.addEventListener('touchend', () => { isDragging = false; });

        draw();
    </script>
</body>
</html>
