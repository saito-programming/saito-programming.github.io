<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>JSシューター - Saito Programming Hub</title>
    <style>
        body { 
            /**background: #1a1a1a;**/ display: flex; flex-direction: column;
            justify-content: center; align-items: center; 
            /**height: 100vh;**/ margin: 0; /**color: white;**/ font-family: sans-serif;
        }
        canvas { background: #000; border: 3px solid #000; }
        .ui { margin-top: 10px; text-align: center; }
        #connect-btn { 
            margin-top:10px;padding: 10px 20px; background: #00d2ff; border: none; 
            border-radius: 5px; cursor: pointer; font-weight: bold; margin-bottom: 10px;
        }
        #connect-btn:hover { background: #008fb3; }
    </style>
</head>
<body>

    <button id="connect-btn">マイクロビットと接続 (シリアル通信)</button>
    <canvas id="gameCanvas" width="400" height="500"></canvas>
    <div class="ui">
        [W,A,S,D]: Move | [K]: Shot | [R]: Restart<br>
        <small id="status">シリアル通信: 未接続</small>
    </div>

    <div style="padding-bottom:20px;">
    	<a href="/">戻る</a>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- ゲーム変数の初期化 ---
let player, bullets, enemies, keys, score, isGameOver, wasKPressed;

function init() {
    player = { x: 185, y: 440, size: 25, speed: 6 };
    bullets = [];
    enemies = [];
    keys = {}; // ここにキーボードとシリアルの両方の状態を格納
    score = 0;
    isGameOver = false;
    wasKPressed = false;
}

// --- キーボード入力監視 ---
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// --- Web Serial API 実装 ---
const connectBtn = document.getElementById('connect-btn');
const statusText = document.getElementById('status');

connectBtn.addEventListener('click', async () => {
    try {
        const port = await navigator.serial.requestPort();
        await port.open({ baudRate: 115200 });
        statusText.innerText = "シリアル通信: 接続済み (115200bps)";
        connectBtn.style.display = "none";

        const reader = port.readable.getReader();
        while (true) {
            const { value, done } = await reader.read();
			if (done) break;
            
            // マイコンから送られてきたデータを文字列に変換
            const data = new TextDecoder().decode(value).trim().toLowerCase();
			
            // シリアル入力をキーボード入力用のkeysオブジェクトに反映
            handleSerialInput(data);
        }
    } catch (error) {
        console.error("Serial Error:", error);
        statusText.innerText = "シリアル通信: 接続失敗";
    }
});

function handleSerialInput(data) {
    // 全てのキーを一旦オフにする（シリアルが「押しっぱなし」を送信し続けない想定の場合）
    // もしマイコン側で「押した時」と「離した時」を制御しているなら、ここはロジック調整が必要です。
    // 今回は「受信した文字に対応する動作を一定時間実行する」簡易版です。
console.log(data);
    if (data.includes('w')) { keys['KeyW'] = true; setTimeout(() => keys['KeyW'] = false, 100); }
    if (data.includes('s')) { keys['KeyS'] = true; setTimeout(() => keys['KeyS'] = false, 100); }
    if (data.includes('a')) { keys['KeyA'] = true; setTimeout(() => keys['KeyA'] = false, 100); }
    if (data.includes('d')) { keys['KeyD'] = true; setTimeout(() => keys['KeyD'] = false, 100); }
    if (data.includes('k')) { keys['KeyK'] = true; setTimeout(() => keys['KeyK'] = false, 100); }
    if (data.includes('r')) { keys['KeyR'] = true; setTimeout(() => keys['KeyR'] = false, 100); }
}

// --- メインループ (変更なし) ---
function update() {
    if (isGameOver) {
        if (keys['KeyR']) init();
        return;
    }

    if (keys['KeyW'] && player.y > 0) player.y -= player.speed;
    if (keys['KeyS'] && player.y < canvas.height - player.size) player.y += player.speed;
    if (keys['KeyA'] && player.x > 0) player.x -= player.speed;
    if (keys['KeyD'] && player.x < canvas.width - player.size) player.x += player.speed;

    if (keys['KeyK'] && !wasKPressed) {
        bullets.push({ x: player.x + player.size/2 - 2, y: player.y, speed: 10 });
    }
    wasKPressed = keys['KeyK'];

    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= bullets[i].speed;
        if (bullets[i].y < -20) bullets.splice(i, 1);
    }

    if (Math.random() < 0.03) {
        enemies.push({ x: Math.random()*(canvas.width-30), y: -30, size: 30, speed: 3 });
    }

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.y += e.speed;
        if (player.x < e.x + e.size && player.x + player.size > e.x &&
            player.y < e.y + e.size && player.y + player.size > e.y) {
            isGameOver = true;
        }
        for (let j = bullets.length - 1; j >= 0; j--) {
            let b = bullets[j];
            if (b.x < e.x + e.size && b.x + 5 > e.x && b.y < e.y + e.size && b.y + 10 > e.y) {
                enemies.splice(i, 1); bullets.splice(j, 1); score += 100; break;
            }
        }
        if (e && e.y > canvas.height) enemies.splice(i, 1);
    }
}

function draw() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffff00';
    bullets.forEach(b => ctx.fillRect(b.x, b.y, 4, 10));
    ctx.fillStyle = '#00d2ff';
    ctx.fillRect(player.x, player.y, player.size, player.size);
    ctx.fillStyle = '#ff4b2b';
    enemies.forEach(e => ctx.fillRect(e.x, e.y, e.size, e.size));
    ctx.fillStyle = '#fff'; ctx.font = '18px Arial'; ctx.textAlign = 'left';
    ctx.fillText(`SCORE: ${score}`, 15, 30);

    if (isGameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = 'bold 30px Arial';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        ctx.font = '18px Arial'; ctx.fillText('Press [R] to Restart', canvas.width/2, canvas.height/2 + 45);
        ctx.textAlign = 'left';
    }
    requestAnimationFrame(() => { update(); draw(); });
}

init();
draw();
</script>
</body>
</html>
